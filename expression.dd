Ddoc

$(SPEC_S 式,

        $(P CやC++プログラマの方は、Dの式を非常に親しみやすく感じるでしょう。
	いくつか面白い追加もあります。
        )

        $(P 式は、結果の値を計算するために使用されます。
	この値は、変数へ代入したり、判定に用いたり、あるいは無視して捨てることもできます。
	式には副作用が伴うことがあります。
        )

<h2><a name="order-of-evaluation">評価順序n</a></h2>

        $(P 以下の二項演算子式は、かならず
	左から右に評価されます:)

        $(P
$(V2
        $(GLINK OrExpression),
        $(GLINK XorExpression),
        $(GLINK AndExpression),
        $(GLINK CmpExpression),
        $(GLINK ShiftExpression),
        $(GLINK AddExpression),
        $(GLINK CatExpression),
        $(GLINK MulExpression),
        $(GLINK PowExpression),
)
        $(GLINK CommaExpression),
        $(GLINK OrOrExpression),
        $(GLINK AndAndExpression)
        )

        $(P 以下の二項演算子式は、
	実装定義の順序で実行されます:)

        $(P
        $(GLINK AssignExpression),
$(V1
        $(GLINK OrExpression),
        $(GLINK XorExpression),
        $(GLINK AndExpression),
        $(GLINK CmpExpression),
        $(GLINK ShiftExpression),
        $(GLINK AddExpression),
        $(GLINK CatExpression),
        $(GLINK MulExpression),
)
        関数引数
        )

        $(P 
        未定義の評価順序に依存するようなコードは誤りです。
	例えば次のコードは不正です：
        )
-------------
i = i++;
c = a + (a = b);
func(++i, ++i);
-------------
        $(P 式の値が評価順序に依存しているとコンパイラが判断したら、
	コンパイラはその式をエラーとすることができます。
	（必ずエラーになるとは限りませんが。）
	この種のエラー検知の精度は、実装の質の問題です。
        )

<h2><a name="Expression">式</a></h2>

$(GRAMMAR
$(GNAME Expression):
    $(I CommaExpression)

$(GNAME CommaExpression):
    $(GLINK AssignExpression)
    $(GLINK AssignExpression) $(B ,) $(I CommaExpression)
)

        まず最初に $(B ,) の左の式が評価され、
	次に右が評価されます。
	この式全体の型、及び値は、右の式の型と値となります。


<h2>代入式</h2>

$(GRAMMAR
$(GNAME AssignExpression):
    $(GLINK ConditionalExpression)
    $(GLINK ConditionalExpression) $(B =) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B +=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B -=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B *=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B /=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B %=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B &=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B |=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B ^=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B ~=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B &lt;&lt;=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B &gt;&gt;=) $(I AssignExpression)
    $(GLINK ConditionalExpression) $(B &gt;&gt;&gt;=) $(I AssignExpression)
$(V2
    $(GLINK ConditionalExpression) $(B ^^=) $(I AssignExpression))
)

	右辺の結果は暗黙に左辺式の型へ変換され、
	代入されます。
	この式全体の結果型は左辺の式の型で、
	値は代入後の左辺値です。
        <p>

	左辺は、lvalue でなくてはなりません。

<h3>代入演算子式</h3>

	代入演算子式、例えば：

--------------
a $(I op)= b
--------------

	は、意味的には

--------------
a = cast(typeof(a))(a $(I op) b)
--------------

        $(P と同等です、違いは、)

	$(UL
	$(LI オペランド $(D a) が一度しか評価されない)
	$(LI $(I op) のオーバーロードと $(I op)= のオーバーロードは違う関数を使う)
	$(LI $(D >>>=) の左オペランドはシフトの前に整数の昇格を通らない)
	)

<h2>条件式</h2>

$(GRAMMAR
$(GNAME ConditionalExpression):
    $(GLINK OrOrExpression)
    $(GLINK OrOrExpression) $(B ?) $(GLINK Expression) $(B :) $(I ConditionalExpression)
)

	まず、一つ目の式を評価し、
	bool値へ変換します。
	結果がtrueなら、二番目の式が評価され、
	式全体の値はその式の評価結果となります。
	結果がfalseなら、三番目の式が評価され、
	式全体の値は三番目の式の評価結果です。
	もし二番目の式と三番目の式のどちらか一方でもvoid型ならば、
	全体の型もvoidになります。そうでなければ、全体の型は
	二番目と三番目の式の型から暗黙に変換できる共通の型です。

<h2>OrOr 式</h2>

$(GRAMMAR
$(GNAME OrOrExpression):
    $(GLINK AndAndExpression)
    $(I OrOrExpression) $(B ||) $(GLINK AndAndExpression)
)

        $(I OrOrExpression) の結果は、
	右の式の型がvoidならばvoid、
	そうでなければboolです。
        <p>

        まず、左の式が評価されます。

	評価結果をboolに変換した結果がtrueだったならば、
	右の式は評価されません。
	全体の型がboolの場合は、
	この時は式の値はtrueとなります。

	左の式がfalseだった時は、
	右の式が評価されます。
	全体の型がboolの場合は、
	式の値は右の式の評価結果を
	bool に変化したものです。


<h2>AndAnd 式</h2>

$(V1
$(GRAMMAR
$(GNAME AndAndExpression):
    $(GLINK OrExpression)
    $(I AndAndExpression) $(B &&) $(GLINK OrExpression)
)
)
$(V2
$(GRAMMAR
$(GNAME AndAndExpression):
    $(GLINK OrExpression)
    $(I AndAndExpression) $(B &&) $(GLINK OrExpression)
    $(GLINK CmpExpression)
    $(I AndAndExpression) $(B &&) $(GLINK CmpExpression)
)
)

        $(P $(I AndAndExpression) の結果は、右の式の型がvoidならばvoid、
	そうでなければboolです。
        )

        $(P まず、左の式が評価されます。
        )

        $(P 評価結果をboolに変換した結果がfalseだったならば、
	右の式は評価されません。
	全体の型がboolの場合は、
	この時は式の値はfalseとなります。
        )

        $(P 左の式がtrueだった時は、
	右の式が評価されます。
	全体の型がboolの場合は、
	式の値は右の式の評価結果を
	bool に変換したものです。
        )


<h2>ビット演算式</h2>

        ビット演算式では、オペランドどうしのビット毎の演算が行われます。
	オペランドどうしは整数型でなくてはなりません。
	まずデフォルトの整数型の昇格が行われ、
	その後にビット演算がなされます。

<h3>Or 式</h3>

$(GRAMMAR
$(GNAME OrExpression):
    $(GLINK XorExpression)
    $(I OrExpression) $(B |) $(GLINK XorExpression)
)

	ビット毎のOR演算です。

<h3>Xor 式</h3>

$(GRAMMAR
$(GNAME XorExpression):
    $(GLINK AndExpression)
    $(I XorExpression) $(B ^) $(GLINK AndExpression)
)

	ビット毎のXOR演算です。

<h3>And 式</h3>

$(V1
$(GRAMMAR
$(GNAME AndExpression):
    $(GLINK CmpExpression)
    $(I AndExpression) $(B &) $(GLINK CmpExpression)
)
)
$(V2
$(GRAMMAR
$(GNAME AndExpression):
    $(GLINK ShiftExpression)
    $(I AndExpression) $(B &) $(GLINK ShiftExpression)
)
)
	ビット毎のAND演算です。


<h2>比較式</h2>

$(GRAMMAR
$(GNAME CmpExpression):
    $(GLINK ShiftExpression)
    $(GLINK EqualExpression)
    $(GLINK IdentityExpression)
    $(GLINK RelExpression)
    $(GLINK InExpression)
)

<h2>等値式</h2>

$(GRAMMAR
$(GNAME EqualExpression):
    $(GLINK ShiftExpression) $(B ==) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !=) $(GLINK ShiftExpression)
)

        等値式では、２つのオペランドが等しいかどうか ($(B ==))
        あるいは等しくないか ($(B !=))
		がチェックされます。
		結果の型はboolで、
        比較の前に双方のオペランドは共通の型へと変換されます。
        <p>

	整数かポインタの比較であれば、"等しい" というのは、
	"ビットパターンが一致すること" として定義されます。
	構造体どうしの"等しい"も、
	オブジェクト全体のビットパターンが一致すること、
	です。（整列の際の穴の存在も、
	コンパイラが初期化時に0で埋めておくなどの方法で
	考慮されています）。
	浮動小数点数の場合は多少複雑です。-0 と +0 は等しいと判定されます。
	どちらか一方でも NaN であれば、 == はfalse、!=はtrueになります。
	それ以外の場合は、ビットパターンで比較されます。
        <p>

        複素数の場合、== は以下と同じです:

---
x.re == y.re && x.im == y.im
---

        != は次と同じです：

---
x.re != y.re || x.im != y.im
---

        $(P クラスや構造体オブジェクトであれば、 $(D (a == b))
        という式は、
        $(D a.opEquals(b)) と書き換えられ、 $(D (a != b)) は
        $(D !a.opEquals(b)) と書き換えられます。
        )

        $(P 演算子 $(CODE ==) と $(CODE !=)
	は、
	オブジェクトの内容を比較するものです。従って、
        内容を持たない $(CODE null) とオブジェクトを比較するのは不正なコードです。
        $(CODE null) かどうかの検査には $(CODE is) と $(CODE !is) 演算子を代わりに使用してください。
        )

---
class C;
C c;
if (c == null)  // エラー
  ...
if (c is null)  // ok
  ...
---

        $(P 静的/動的な配列の等しさは、
		配列の長さが等しく、
		かつ、全ての要素が等しいこと、と定義されます。
        )

<h3>同一性式</h3>

$(GRAMMAR
$(GNAME IdentityExpression):
    $(GLINK ShiftExpression) $(B is) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !is) $(GLINK ShiftExpression)
)

        $(P $(B is)  は二つのオブジェクトの同一性をチェックします。
	同一でないことのチェックは、 $(D $(I e1) $(B !is) $(I e2)).
         を使います。
	結果の型はboolで、
	比較の前に双方のオペランドは共通の型へと変換されます。
        )

        $(P クラスオブジェクトの場合は、二つの参照が同じオブジェクトを
	指しているかどうかのチェックになります。
        $(B is) では、null 参照との比較も可能です。
        )

        $(P 構造体オブジェクトの場合は、構造体のビット列が同一であること、
	として定義されています。
        )

        $(P 静的あるいは動的な配列の場合は、二つとも同じ配列を指しているかどうか、
	で同一性が判定されます。
        )

        $(P その他の型に関しては、
	同一性は同値性と同じように定義されています。
        )

        $(P 同一性演算子 $(B is) はオーバーロードできません。
        )

<h2>関係式</h2>

$(GRAMMAR
$(GNAME RelExpression):
    $(GLINK ShiftExpression) $(B &lt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B &lt;=) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B &gt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B &gt;=) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&lt;&gt;=) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&lt;&gt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B &lt;&gt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B &lt;&gt;=) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&gt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&gt;=) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&lt;) $(GLINK ShiftExpression)
    $(GLINK ShiftExpression) $(B !&lt;=) $(GLINK ShiftExpression)
)

	まず、オペランド双方に整数の昇格が行われます。
	結果の型はboolです。
        <p>

	クラスオブジェクトの場合は、左オペランドに対して Object.opCmp()
	の呼び出し結果と整数0、を演算子で比較した結果が式全体の値となります。
	つまり、関係式 (o1 op o2) の結果は次のように定義されます：

---
(o1.opCmp(o2) op 0)
---

        どちらかが $(B null) の場合、エラーになります。
        <p>

	静的/動的な配列の場合、
	"二つの配列の中で等しくない最初の要素"
	に op を適用した結果が、配列どうしの関係式opの結果となります。
	有効な全要素が等しい時は、サイズが小さい配列の方がより"小さい"
	とします。


<h3>整数比較</h3>

        $(P オペランドがどちらも整数型だった場合、
	整数比較が行われます。
        )

        $(TABLE2 整数比較演算子,
        $(TR
        $(TH 演算子)$(TH 関係)
        )$(TR
        $(TD &lt;)              $(TD 小さい)
        )$(TR
        $(TD &gt;)              $(TD 大きい)
        )$(TR
        $(TD &lt;=)             $(TD 以下)
        )$(TR
        $(TD &gt;=)             $(TD 以上)
        )$(TR
        $(TD ==)                $(TD 等しい)
        )$(TR
        $(TD !=)                $(TD 等しくない)
        )
        )

        $(P &lt;, &lt;=, &gt;, &gt;= 式の時は、
	符号付き整数と符号なし整数の比較はエラーとなります。
	明示的にどちらかのオペランドをキャストしてください。
        )

<h3><a name="floating_point_comparisons">浮動小数点数比較</a></h3>

	オペランドがどちらも浮動小数点数型だった場合、
	浮動小数点数比較が行われます。
        <p>

	実用に値する浮動小数点数演算を定義するには、
	NaN を考慮に入れなくてはいけません。
	特に、関係演算のオペランドとしては NaN を取ることができます。
	二つの浮動小数点数の関係としては、
	より小さい、より大きい、等しい、順序づけ不可能（一方がNaN）
	の４種類があり、
	演算子もこれに応じて14種類の条件を表現しています：
        <p>

        $(TABLE2 浮動小数点数演算子,
        $(TR
        $(TH 演算子)
        $(TH より大きい)
        $(TH より小さい)
        $(TH 等しい)
        $(TH 順序づけ不可能red)
        $(TH 例外)
        $(TH 関係)
        )
        $(TR
        $(TD ==)        $(TD F)$(TD F)$(TD T)$(TD F)$(TD no)    $(TD 等しい)
        )
        $(TR
        $(TD !=)        $(TD T)$(TD T)$(TD F)$(TD T)$(TD no)    $(TD 順序づけ不可能, より小さい, より大きい)
        )
        $(TR
        $(TD &gt;)      $(TD T)$(TD F)$(TD F)$(TD F)$(TD yes)   $(TD より大きい)
        )
        $(TR
        $(TD &gt;=)     $(TD T)$(TD F)$(TD T)$(TD F)$(TD yes)   $(TD 以上)
        )
        $(TR
        $(TD &lt;)      $(TD F)$(TD T)$(TD F)$(TD F)$(TD yes)   $(TD より小さい)
        )
        $(TR
        $(TD &lt;=)     $(TD F)$(TD T)$(TD T)$(TD F)$(TD yes)   $(TD 以下)
        )
        $(TR
        $(TD !&lt;&gt;=) $(TD F)$(TD F)$(TD F)$(TD T)$(TD no)   $(TD 順序づけ不可能)
        )
        $(TR
        $(TD &lt;&gt;)  $(TD T)$(TD T)$(TD F)$(TD F)$(TD yes)   $(TD より小さい, より大きい)
        )
        $(TR
        $(TD &lt;&gt;=) $(TD T)$(TD T)$(TD T)$(TD F)$(TD yes)   $(TD より小さい, より大きい, 等しい)
        )
        $(TR
        $(TD !&lt;=)    $(TD T)$(TD F)$(TD F)$(TD T)$(TD no)    $(TD 順序づけ不可能か、より大きい)
        )
        $(TR
        $(TD !&lt;)     $(TD T)$(TD F)$(TD T)$(TD T)$(TD no)    $(TD 順序づけ不可能か、以上)
        )
        $(TR
        $(TD !&gt;=)    $(TD F)$(TD T)$(TD F)$(TD T)$(TD no)    $(TD 順序づけ不可能か、より小さい)
        )
        $(TR
        $(TD !&gt;)     $(TD F)$(TD T)$(TD T)$(TD T)$(TD no)    $(TD 順序づけ不可能か、以下)
        )
        $(TR
        $(TD !&lt;&gt;) $(TD F)$(TD F)$(TD T)$(TD T)$(TD no)    $(TD 順序づけ不可能か、等しい)
        )
        )

        <h4>注:</h4>

        $(OL
        $(LI 浮動小数点数の場合、
         $(CODE ($(I a) !$(I op) $(I b)))
         は $(CODE !($(I a op b))) と同義ではありません。)
        $(LI "順序づけ不可能" とは、オペランドの一方または両方が NaN という意味です。)
        $(LI "例外" とは、どちらかがNaNだった時に $(I Invalid Exception)
                が発生することを意味します。これは、例外がthrowされるのとは異なります。
                $(I Invalid Exception) が発生したかどうかのチェックは、
                $(DPLLINK phobos/std_c_fenv.html, std.c.fenv) の関数で行います。
        )
        )

<h3><a name="class_comparisons">クラスの比較</a></h3>

        $(P クラスオブジェクトに対しては、
	比較演算子はオブジェクトの内容を比較するものです。
	従って、
	内容を持たない $(CODE null) とオブジェクトを比較するのは不正なコードです。
        )

---
class C;
C c;
if (c < null)  // エラー
  ...
---

<h2>In 式</h2>

$(GRAMMAR
$(GNAME InExpression):
    $(GLINK ShiftExpression) $(B in) $(GLINK ShiftExpression)
$(V2    $(GLINK ShiftExpression) $(B !in) $(GLINK ShiftExpression))
)

        $(P 連想配列では、値が配列の要素かどうかを調べることができます：
        )

-------------
int foo[char[]];
...
if ("hello" in foo)
    ...
-------------

        $(P $(B in) 式は、
        $(B &lt;), $(B &lt;=)などの関係式と
	同じ優先度を持ちます。
	要素が配列中に存在しなければ $(I InExpression) は $(B null)
        になります。存在すれば、
	配列中の要素へのポインタになります。
        )

        $(V2 $(P $(B !in) 式は $(B in)
        式の否定を返します。
        ))

<h2>Shift 式</h2>

$(GRAMMAR
$(GNAME ShiftExpression):
    $(GLINK AddExpression)
    $(I ShiftExpression) $(B &lt;&lt;) $(GLINK AddExpression)
    $(I ShiftExpression) $(B &gt;&gt;) $(GLINK AddExpression)
    $(I ShiftExpression) $(B &gt;&gt;&gt;) $(GLINK AddExpression)
)

        $(P 	オペランドは整数型でなくてはならず、
	演算前に昇格が行われます。
	結果は昇格後の左オペランドと同じ型を持ち、
	値は左オペランドのビットを右オペランド分だけシフトした値です。
        )

        $(P $(B &lt;&lt;) は左シフトです。
        $(B &gt;&gt;) は符号付き右シフトです。
        $(B &gt;&gt;&gt;) は符号無し右シフトです。
        )

        $(P シフトされる型のビット数より多くシフトしようとするのは
	不正です：
	)

-------------
int c;
c << 33;        // エラー
-------------

<h2>Add 式</h2>

$(GRAMMAR
$(GNAME AddExpression):
    $(GLINK MulExpression)
    $(I AddExpression) $(B +) $(GLINK MulExpression)
    $(I AddExpression) $(B -) $(GLINK MulExpression)
    $(GLINK CatExpression)
)

        $(P オペランドが整数型ならば昇格が行われます。
	さらに、
	共通の型へと通常の算術変換がなされます。
        )

        $(P もしどちらか一方が浮動小数点数ならば、
	もう片方も暗黙に浮動小数点数に変換され、
	共通の型へと変換されます。
        )

        $(P 演算子 $(B +) か $(B -) で、
	第一オペランドがポインタで第二オペランドが整数型の時は、
	結果の型は第一オペランドの型と同じになります。式の値は、
	第一オペランドのポインタに、第二オペランドに型のサイズを掛けた結果を
	足した（引いた）ポインタとなります。
        )

        $(P 第二オペランドがポインタで第一引数が整数型、そして
	演算子が $(B +) の時は、
	オペランドを逆転して、
	上で述べた演算が行われます。
        )

        $(P どちらのオペランドもポインタで、演算子が $(B +)
        の場合、これは不正です。演算子が $(B -) の場合、ポインタのアドレス値同士が減算され、
	結果がオペランドの指す型のサイズで割り算されます。
	二つのポインタの型が違う場合エラーです。
        )

        $(P 浮動小数点数に対する加算は結合則を満たしません。
        )

<h2>Cat 式</h2>

$(GRAMMAR
$(GNAME CatExpression):
    $(I AddExpression) $(B ~) $(GLINK MulExpression)
)

        $(P $(I CatExpression) は配列同士を結合し、
	結果の動的配列を返します。結合される配列は、
	同じ型の要素を持つ配列である必要があります。片方のオペランドが配列で、
	もう一方がその配列の要素型だった場合は、
	その要素だけを含む長さ１の配列に変換されてから、
	結合が行われます。
        )

<h2>Mul 式</h2>

$(GRAMMAR
$(GNAME MulExpression):
    $(GLINK UnaryExpression)
    $(I MulExpression) $(B *) $(GLINK UnaryExpression)
    $(I MulExpression) $(B /) $(GLINK UnaryExpression)
    $(I MulExpression) $(B %) $(GLINK UnaryExpression)
)

        $(P オペランドが整数型ならば昇格が行われます。
	さらに、
	共通の型へと通常の算術変換がなされます。
        )

        $(P 整数型の場合、$(B *), $(B /), $(B %) がそれぞれ
	掛け算、割り算, 余り に対応しています。
	掛け算ではオーバーフローは無視され、
	整数型に収まる下位ビットだけが結果として残ります。
        )

        $(P 整数の $(B /) と $(B %) 演算については、
	商は 0 に向かって丸められ、余りは割られる数と同じ符号になります。
	割る数が 0 だった場合、
	例外が送出されます。
        )

        $(P 浮動小数点数では、* と / は
	各演算は IEEE 754 で規定された演算に対応します。 % は IEEE754 の剰余とは一致しません。
	例えば、15.0 % 10.0 == 5.0 ですが、
 	IEEE 754 では remainder(15.0,10.0) == -5.0 です。
        )

        $(P 浮動小数点数に対するMul式は結合則を満たしません。
        )

<h2><a name="UnaryExpression">単項演算式</a></h2>

$(GRAMMAR
$(GNAME UnaryExpression):
    $(B &amp;) $(I UnaryExpression)
    $(B ++) $(I UnaryExpression)
    $(B --) $(I UnaryExpression)
    $(B *) $(I UnaryExpression)
    $(B -) $(I UnaryExpression)
    $(B +) $(I UnaryExpression)
    $(B !) $(I UnaryExpression)
    $(GLINK ComplementExpression)
    $(B $(LPAREN)) $(GLINK2 declaration, Type) $(B $(RPAREN) .) $(IDENTIFIER)
    $(GLINK NewExpression)
    $(GLINK DeleteExpression)
    $(GLINK CastExpression)
    $(V1 $(GLINK PostfixExpression))$(V2 $(GLINK PowExpression))
)

<h3>Complement 式</h3>

$(GRAMMAR
$(GNAME ComplementExpression):
    $(B ~) $(I UnaryExpression)
)

	$(P $(I ComplementExpression) はboolを除く整数型に対して働き、
	値中の全てのビットを反転します。)

	$(P 注: C や C++ と異なり、
	ビット反転の前に通常の整数の昇格が行われることはありません。
	)

<h3>New 式</h3>

$(GRAMMAR
$(GNAME NewExpression):
	$(B new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type) $(B [) $(GLINK AssignExpression) $(B ])
	$(B new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type) $(B $(LPAREN)) $(GLINK ArgumentList) $(B $(RPAREN))
	$(B new) $(I AllocatorArguments)$(OPT) $(GLINK2 declaration, Type)
	$(GLINK2 class, NewAnonClassExpression)

$(GNAME AllocatorArguments):
	$(B $(LPAREN)) $(GLINK ArgumentList)$(OPT) $(B $(RPAREN))

$(GNAME ArgumentList):
    $(GLINK AssignExpression)
$(V2      $(GLINK AssignExpression) $(B ,)
)    $(GLINK AssignExpression) $(B ,) $(I ArgumentList)
)

        $(P $(I NewExpression) は、ガベージコレクタのヒープ（デフォルト）、
	もしくはクラス/構造体特有のアロケータを使ってメモリを確保するのに使われます。
        )

        $(P 多次元配列を確保するには、
	宣言は前置の型宣言と同じ順番で記述します。
        )

-------------
char[][] foo;   // 文字列の動的配列
...
foo = new char[][30]; // 文字列　30要素の配列　を割付
-------------

        $(P 上のコードは次のように書くこともできます:)

-------------
foo = new char[][](30); // 30個の文字列を割り当て
-------------

        $(P 多重に配列を割り当てるには、引数を複数書きます:)

---------------
int[][][] bar;
...
bar = new int[][][](5,20,30);
---------------

        $(P このコードは、次と同等の意味になります。)

----------
bar = new int[][][5];
foreach (ref a; bar)
{
  a = new int[][20];
  foreach (ref b; a)
  {
    b = new int[30];
  }
}
-----------

        $(P $(B new $(LPAREN)) $(GLINK ArgumentList) $(B $(RPAREN)) がある場合、
        その引数は、
	クラス/構造体特有の
	$(LINK2 class.html#allocators, アロケータ関数)へと、サイズ引数に続けて引き渡されます。
        )

        $(P $(I NewExpression) が、記憶クラス
        $(B scope) つきの関数ローカル変数の初期化式で使用された場合で、
	しかも $(B new) の $(GLINK ArgumentList) が空ならば、
	インスタンス用のメモリは、ヒープやクラス専用のアロケータではなく、
	スタック上から割り当てられます。
        )

<h3>Delete 式</h3>

$(GRAMMAR
$(GNAME DeleteExpression):
    $(B delete) $(GLINK UnaryExpression)
)
        $(P まず、クラスオブジェクトへの参照を指定した場合で、
	そのクラスにデストラクタがある場合は、
	インスタンスに対してデストラクタが呼び出されます。
        )

        $(P 次に、クラスオブジェクトへの参照か構造体へのポインタを指定した場合で、
	そのクラスか構造体で
	delete 演算子がオーバーロードされている場合、
	インスタンスに対してそのdelete演算子が呼び出されます。
        )

        $(P それ以外の場合はガベージコレクタが呼び出され、
	インスタンスに割り当てたメモリは直ちに解放されます。
	ガベージコレクタ以外で割り当てたメモリが使われていた場合、
	動作は未定義になります。
        )

        $(P ポインタや動的配列が指定された場合は、
	ガベージコレクタが呼び出され、
	メモリ領域は直ちに解放されます。
	ガベージコレクタ以外で割り当てたメモリが使われていた場合、
	動作は未定義になります。
        )

        $(P ポインタ、動的配列、参照変数は、
		delete のあと $(B null) にセットされます。
	delete したあと他の参照でデータにアクセスしようとすると、
	未定義動作となります。
        )

        $(P スタックに割り当てられた変数が指定された場合、
	クラスのデストラクタが（もしあれば）呼び出されます。
	ガベージコレクタやクラス専用のアロケータは
	呼び出されません。
        )

<h3>Cast 式</h3>

$(GRAMMAR
$(GNAME CastExpression):
    $(B cast $(LPAREN)) $(GLINK2 declaration, Type) $(B $(RPAREN)) $(GLINK UnaryExpression)
    $(B cast $(LPAREN)) $(I CastQual) $(B $(RPAREN)) $(GLINK UnaryExpression)
    $(B cast $(LPAREN)) $(B $(RPAREN)) $(GLINK UnaryExpression)

$(GNAME CastQual):
    $(B const)
    $(B const shared)
    $(B shared const)
    $(B inout)
    $(B inout shared)
    $(B shared inout)
    $(B immutable)
    $(B shared)
)

        $(P $(I CastExpression) は、 $(I UnaryExpression)
        を別の $(GLINK2 declaration, Type) へと変換します。
        )

-------------
$(B cast)(foo) -p; // (-p) をfoo型にキャスト
(foo) - p;      // fooからpを引き算
-------------

        $(P クラスオブジェクトへの参照を派生クラスへとキャストするときは常に、
	そのダウンキャストが適切なものであるか実行時のチェックが入ります。
	不適切なキャストのときは結果は $(B null) になります。
        $(B 注:) これはC++で言うdynamic_cast演算子と同等の動作をしている、
	と言えるでしょう。
        )

-------------
class A { ... }
class B : A { ... }

void test(A a, B b) {
  B bx = a;         // エラー、キャストが必要
  B bx = cast(B) a; // a が B型ではない場合、bx は null となる
  A ax = b;         // キャスト不要
  A ax = cast(A) b; // no runtime check needed for upcast
}
-------------

        $(P オブジェクト $(D o) がクラス
        $(D B) のインスタンスであることを判定するためには、キャストを使います：
        )

-------------
if ($(B cast)(B) o)
{
  // o は B のインスタンス
}
else
{
  // o は B のインスタンスではない
}
-------------

	$(P ポインタ型とクラス型の間のキャストは、型の塗りつぶし
	(つまり reinterpret_cast) として実行されます。)

	$(P 動的配列を別の型の動的配列にキャストするのは、
	配列のlengthと要素型のsizeを掛け算した結果が一致する時に限ります。
	変換は、reinterpret_cast として行われ、length は要素のsizeの比を考慮して調整されます。
	長さが合わないときは、実行時エラーとなります。)

$(V1
---
import std.stdio;

int main() {
  byte[] a = [1,2,3];
  auto b = cast(int[])a; // 実行時のエラー

  int[] c = [1, 2, 3];
  auto d = cast(byte[])c; // ok
  // prints:
  // [1,0,0,0,2,0,0,0,3,0,0,0]
  writefln(d);
  return 0;
} 
---
)
$(V2
---
import std.stdio;

int main() {
  byte[] a = [1,2,3];
  auto b = cast(int[])a; // 実行時のエラー

  int[] c = [1, 2, 3];
  auto d = cast(byte[])c; // ok
  // prints:
  // [1, 0, 0, 0, 2, 0, 0, 0, 3, 0, 0, 0]
  writeln(d);
  return 0;
} 
---
)
        $(P 浮動小数点数リテラルを別の型へとキャストすると型は変わりますが、
	内部的には、
	定数畳み込みのために、元々の精度を保って保持されます。
        )

---
void test() {
  real a = 3.40483L;
  real b;
  b = 3.40483;     // リテラルはdouble精度に切り詰められない
  assert(a == b);
  assert(a == 3.40483);
  assert(a == 3.40483L);
  assert(a == 3.40483F);
  double d = 3.40483; // 変数に代入されると、精度が切り詰められる
  assert(d != a);     // このため、完全に同じ値ではなくなる
  const double x = 3.40483; // constへの代入は
  assert(x == a);     // 初期化子が可視な場合は切り捨てられない
}
---

        $(P 値 $(I v) から構造体 $(I S) へのキャストは、
	v の型がSと同じではないときに限り、以下のコードと同等です:
        )

---
S(v)
---

        $(P $(GLINK CastQual) へのキャストは、元の $(GLINK UnaryExpression)
		の型の修飾子を置き換えます。)

---
shared int x;
assert(is(typeof(cast(const)x) == const int));
---

        $(P $(GLINK Type) も $(GLINK CastQual) も指定しないキャストは、
        トップレベルの $(B const), $(B immutable), $(B shared), $(B inout)
	型修飾子を
        $(GLINK UnaryExpression) から取り除きます。)

---
shared int x;
assert(is(typeof(cast()x) == int));
---

$(V2
<h2>Pow 式</h2>

$(GRAMMAR
$(GNAME PowExpression):
    $(GLINK PostfixExpression)
    $(GLINK PostfixExpression) ^^ $(GLINK UnaryExpression)
)

        $(P $(I PowExpression) は、
        左オペランドの右オペランド乗を計算します。
        )
)


<h2>後置演算式</h2>

$(GRAMMAR
$(GNAME PostfixExpression):
    $(GLINK PrimaryExpression)
    $(I PostfixExpression) $(B .) $(IDENTIFIER)
    $(I PostfixExpression) $(B .) $(GLINK2 template, TemplateInstance)
    $(I PostfixExpression) $(B .) $(GLINK NewExpression)
    $(I PostfixExpression) $(B ++)
    $(I PostfixExpression) $(B --)
    $(I PostfixExpression) $(B ( ))
    $(I PostfixExpression) $(B $(LPAREN)) $(GLINK ArgumentList) $(B $(RPAREN))
    $(GLINK IndexExpression)
    $(GLINK SliceExpression)
)

<h2>Index 式</h2>

$(GRAMMAR
$(GNAME IndexExpression):
    $(GLINK PostfixExpression) $(B [) $(GLINK ArgumentList) $(B ])
)

        $(P まず $(I PostfixExpression) が評価されます。

        $(I PostfixExpression) が静的配列か動的配列だった場合、
        シンボル $(DOLLAR)
        が配列の長さとして使えます。

        $(I PostfixExpression) が $(I ExpressionTuple),
        だった場合は、シンボル $(DOLLAR)
        はタプルの要素数になります。

        $(GLINK ArgumentList) の評価の際には新しい宣言スコープが作られ、
		$(DOLLAR) はこの範囲でのみ使用できます。
        )

        $(P $(I PostfixExpression) が $(I ExpressionTuple) の場合は、
        $(GLINK ArgumentList) の要素は必ず１つで、
	コンパイル時に整数定数へと評価される式でなければいけません。
        その整数定数 $(I n)  に応じて、
         $(I ExpressionTuple) の第 $(I n) 番目の要素が選択され、
        その値が $(I IndexExpression) 全体の値となります。
        $(I n) が $(I ExpressionTuple) の範囲を外れているとエラーです。
        )

<h2>Slice 式</h2>

$(GRAMMAR
$(GNAME SliceExpression):
    $(GLINK PostfixExpression) $(B [ ])
    $(GLINK PostfixExpression) $(B [) $(GLINK AssignExpression) $(B ..) $(GLINK AssignExpression) $(B ])
)

        $(P まず $(I PostfixExpression) が評価されます。
        $(I PostfixExpression)  が静的配列か動的配列だった場合、
	変数 $(B length)
        (と特殊変数 $(DOLLAR))
        が宣言され、
	その値は配列の長さになります。
        $(GLINK AssignExpression)..$(GLINK AssignExpression)
        の評価の際にはこの新しい宣言スコープが作られ、 $(B length) (と $(DOLLAR)) はこの範囲でのみ使用できます。
        )

        $(P 式の結果は、
		$(I PostfixExpression) の指す配列の、
		先頭の $(I AssignExpression) 
		以上、
        二番目の $(I AssignExpression) 未満、
		の範囲のスライスとなります。 
        )

        $(P $(B [ ]) 形式を使うと、
	スライスは配列全体になります。
        )

        $(P スライスの型は、
        $(I PostfixExpression) の要素の動的配列型となります。
        )

	$(P $(I SliceExpression) は変更可能な lvalue ではありません。)

        $(P $(I PostfixExpression) が $(I ExpressionTuple) のときは、
        スライス式の結果は新しく指定された上限と下限の範囲の $(I ExpressionTuple)
	になります。
	上限と下限はコンパイル時に整数定数へと評価される式でなければなりません。
	範囲の外の値が指定された場合は、
	エラーになります。 
       )

<h2>原始式</h2>

$(GRAMMAR
$(GNAME PrimaryExpression):
    $(IDENTIFIER)
    $(B .)$(IDENTIFIER)
    $(GLINK2 template, TemplateInstance)
    $(B .)$(GLINK2 template, TemplateInstance)
    $(LINK2 #this, $(B this))
    $(LINK2 #super, $(B super))
    $(LINK2 #null, $(B null))
    $(B true)
    $(B false)
    $(B $)
$(V2      $(B __FILE__)
    $(B __LINE__))
    $(GLINK2 lex, IntegerLiteral)
    $(GLINK2 lex, FloatLiteral)
    $(GLINK CharacterLiteral)
    $(GLINK StringLiterals)
    $(GLINK ArrayLiteral)
    $(GLINK AssocArrayLiteral)
    $(GLINK Lambda)
    $(GLINK FunctionLiteral)
    $(GLINK AssertExpression)
    $(GLINK MixinExpression)
    $(GLINK ImportExpression)
    $(DDSUBLINK declaration, BasicTypeX, $(I BasicType)) $(B .) $(IDENTIFIER)
    $(GLINK2 declaration, Typeof)
    $(GLINK TypeidExpression)
    $(GLINK IsExpression)
    $(B $(LPAREN)) $(I Expression) $(B $(RPAREN))
$(V2      $(GLINK2 traits, TraitsExpression))
)

<h3>.Identifier</h3>

        $(IDENTIFIER) はその時点のネストされたスコープではなく、
	モジュールスコープから探索されます。

<h3>$(LNAME2 this, this)</h3>

        $(P 非staticメンバ関数の中では、$(B this)  はその関数を呼んだ
	オブジェクトへの参照となっています。
	構造体での  $(B this) は、
	その構造体インスタンスへのポインタとなります。
    $(B typeof(this)) を明示的に参照してメンバ関数を呼び出した場合は、
	非仮想の関数呼び出しが行われます：
        )

-------------
class A {
  char get() { return 'A'; }

  char foo() { return $(B typeof(this)).get(); }
  char bar() { return $(B this).get(); }
}

class B : A {
  char get() { return 'B'; }
}

void main() {
  B b = new B();

  b.foo();  // returns 'A'
  b.bar();  // returns 'B'
}
-------------

	$(P $(B this) への代入は禁止です。)

<h3>$(LNAME2 super, super)</h3>

        $(P $(B super) は、$(B this)
	を基底クラスへとキャストしたものです。
	基底クラスが存在しない場合はエラーになります。
	また、構造体の中で $(B super)  を使うのもエラーです。
        (クラス $(D Object) のみが基底クラスを持ちません。)
        $(B super) を明示的に参照してメンバ関数を呼び出した場合は、
	非仮想の関数呼び出しが行われます：
        )

	$(P $(B super) への代入は禁止です。)

<h3>$(LNAME2 null, null)</h3>

        $(P $(B null) は、
	ポインタ、関数ポインタ、デリゲート、
	動的配列、連想配列、
	クラスオブジェクトの null 値を表します。
	特定の型にキャストされていないときは、
	(void*) 型となり、
	ポインタ、
	関数ポインタ等々への完全一致の変換が可能です。
	特定の型にキャストされた後も暗黙の変換は可能ですが、
	完全一致扱いにはなりません。
        )

<h3>true, false</h3>

        $(B bool) 型の値で、
	他の整数型にキャストされた場合はそれぞれ
	1 と 0 になります。

<h3><a name="CharacterLiteral">文字リテラル</a></h3>

        文字リテラルは、文字１文字を表していて、
        $(B char), $(B wchar), $(B dchar) のいずれかの型を持ちます。
	\u エスケープシーケンスならば $(B wchar) 型、
        \U エスケープシーケンスならば $(B dchar) 型となります。
	それ以外の場合は、
	その文字を格納できる最小の型になります。

<h3>文字列リテラル</h3>

$(GRAMMAR
$(GNAME StringLiterals):
    $(GLINK2 lex, StringLiteral)
    $(I StringLiterals) $(GLINK2 lex, StringLiteral)
)

        $(P 文字列リテラルは、
	以下の型に（同じ優先度で）暗黙変換されます:
        )

$(V1
        $(TABLE1
        $(TROW $(D char*))
        $(TROW $(D wchar*))
        $(TROW $(D dchar*))
        $(TROW $(D char[]))
        $(TROW $(D wchar[]))
        $(TROW $(D dchar[]))
        )
)
$(V2
        $(TABLE1
        $(TROW $(D immutable(char)*))
        $(TROW $(D immutable(wchar)*))
        $(TROW $(D immutable(dchar)*))
        $(TROW $(D immutable(char)[]))
        $(TROW $(D immutable(wchar)[]))
        $(TROW $(D immutable(dchar)[]))
        )
)
        $(P 文字列リテラルの末尾には 0 が必ず入っています。
	これは $(CODE const char*) 文字列を期待する
	C/C++ の関数にリテラルを渡しやすくするためです。
	この 0 は文字列リテラルの $(CODE .length)
       プロパティには含まれません。
        )

<h3>配列リテラル</h3>

$(GRAMMAR
$(GNAME ArrayLiteral):
    $(B [) $(GLINK ArgumentList) $(B ])
)

        $(P 配列リテラルは、[ と ] で挟んで、カンマで区切った $(GLINK AssignExpression)
         のリストです。
        $(I AssignExpression) は配列の要素をあらわし、
	配列の長さは要素の個数になります。
	配列リテラル全体の型としては、先頭要素の型が採用されます。
	ほかの要素は全て、
	その型へと暗黙変換されます。
	その型が静的配列型であれば、
	動的配列に変換されます。
        )

---
[1,2,3];  // int[3] 型。要素は 1, 2, 3
[1u,2,3]; // uint[3] 型。引数は 1u, 2u, 3u
---

        $(P $(GLINK ArgumentList) の引数のどれかが
        $(I ExpressionTuple)であった場合は、
	 そのタプルの場所に引数として $(I ExpressionTuple) の要素が挿入されます。
        )

        $(P 配列リテラルはGC管理されたヒープに配置されます。
	従って、安全に関数から返すことができます:)

---
int[] foo() {
  return [1, 2, 3];
}
---

        $(P 配列リテラルが別の配列型にキャストされた場合、
	要素それぞれが新しい要素型にキャストされます。
	リテラルでない配列がキャストされた場合、
	配列が新しい型として再解釈され、長さが再計算されます:
        )

---
import std.stdio;

void main() {
  // 配列リテラルのキャスト
  const short[] ct = cast(short[]) [cast(byte)1, 1];
  writeln(ct);  // 出力は [1, 1]

  // それ以外の配列のキャスト
  short[] rt = cast(short[]) [cast(byte)1, cast(byte)1].dup;
  writeln(rt);  // 出力は [257]
}
---


<h3>連想配列リテラル</h3>

$(GRAMMAR
$(GNAME AssocArrayLiteral):
    $(B [) $(GLINK KeyValuePairs) $(B ])

$(GNAME KeyValuePairs):
    $(GLINK KeyValuePair)
    $(GLINK KeyValuePair) $(B ,) $(I KeyValuePairs)

$(GNAME KeyValuePair):
    $(GLINK KeyExpression) $(B :) $(GLINK ValueExpression)

$(GNAME KeyExpression):
    $(GLINK AssignExpression)

$(GNAME ValueExpression):
    $(GLINK AssignExpression)
)

        $(P 連想配列リテラルは、角括弧 [ と ] の間で
	コンマで区切られた
        $(I key):$(I value)  ペアのリストです。
	空リストであってはいけません。
	１個目のkeyの型が全体のkeyの型として使用され、
	残りの key
	はその型へと暗黙変換されます。
	１個目のvalueの型が全体のvalueの型として使用され、
	残りの value
	はその型へと暗黙変換されます。
	連想配列リテラルは、
	静的初期化には使用できません
        )

---
[21u:"he",38:"ho",2:"hi"]; // 型は char[2][uint] で、
                           // keyが 21u, 38u, 2u。
                           // valueが "he", "ho", "hi"
---

        $(P $(I KeyValuePairs) のどれかが
        $(I ExpressionTuple)であった場合は、
		そのタプルの場所に引数として $(I ExpressionTuple) の要素が挿入されます。
        )

<h3>ラムダ式</h3>

$(GRAMMAR
$(GNAME Lambda):
        $(IDENTIFIER) $(B =&gt;) $(GLINK AssignExpression)
        $(GLINK ParameterAttributes) $(B =&gt;) $(GLINK AssignExpression)
)

	$(P $(I Lambda) は $(GLINK FunctionLiteral) を簡単に書くための略記構文です。
	この構文は
	)
---
delegate ( $(IDENTIFIER) ) { return $(I AssignExpression); }
---

	$(P あるいは次と等価です:)

---
delegate $(I ParameterAttributes) { return $(I AssignExpression); }
---

<h3>関数リテラル</h3>

$(GRAMMAR
$(GNAME FunctionLiteral):
        $(B function) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterAttributes) $(OPT) $(GLINK2 function, FunctionBody)
        $(B delegate) $(GLINK2 declaration, Type)$(OPT) $(GLINK ParameterAttributes) $(OPT) $(GLINK2 function, FunctionBody)
        $(GLINK ParameterAttributes) $(GLINK2 function, FunctionBody)
        $(GLINK2 function, FunctionBody)

$(GNAME ParameterAttributes):
    $(GLINK2 declaration, Parameters)
$(V2      $(GLINK2 declaration, Parameters) $(GLINK2 declaration, FunctionAttributes))
)

        $(I FunctionLiteral) によって、式の中に直接
		無名関数や無名デリゲートを埋め込むことが可能になります。
        $(I Type) は関数やデリゲートの返値型です。
        $(I FunctionBody) の $(I ReturnStatement) から推論できる場合は、
		省略してもかまいません。
        $(B $(LPAREN)) $(GLINK ArgumentList) $(B $(RPAREN))
        は関数の引数リストです。
	省略した場合は、空の引数リスト $(B ( )) として処理されます。
	関数リテラル式の型は、関数へのポインタか
	デリゲートへのポインタになります。
	キーワード $(B function) や $(B delegate)
        が省略された場合のデフォルトは delegate です。
        <p>

	例として：

-------------
int function(char c) fp; // 関数へのポインタを宣言

void test() {
  static int foo(char c) { return 6; }

  fp = &foo;
}
-------------

	これは次と完全に等価です：

-------------
int function(char c) fp;

void test() {
  fp = $(B function int(char c) { return 6;}) ;
}
-------------

	あるいは、次のコードは：

-------------
int abc(int delegate(long i));

void test() {
  int b = 3;
  int foo(long c) { return 6 + b; }

  abc(&foo);
}
-------------

	以下と全く同等です：

-------------
int abc(int delegate(long i));

void test() {
  int b = 3;

  abc( $(B delegate int(long c) { return 6 + b; }) );
}
-------------

        $(P 次の例では、返値型 $(B int)
        が自動推論されています:)

-------------
int abc(int delegate(long i));

void test() {
  int b = 3;

  abc( $(B (long c) { return 6 + b; }) );
}
-------------

	無名デリゲートは、文リテラルのように使うことができます。
	例えば、以下は任意の文をループ実行する例です:

-------------
double test() {
  double d = 7.6;
  float f = 2.3;

  void loop(int k, int j, void delegate() statement) {
    for (int i = k; i < j; i++) {
      statement();
    }
  }

  loop(5, 100, $(B { d += 1; }) );
  loop(3, 10,  $(B { f += 3; }) );

  return d + f;
}
-------------

        $(DDSUBLINK function, nested, ネスト関数)  と対比すると、
		$(B function) を使う方は static ないしはネストしていない関数と似ていて、
        $(B delegate) を使う方は、
	非staticないしはネストした関数と似ています。言い換えると、
	delegateリテラルは周囲の関数のスタック変数にアクセスできますが、
	関数リテラルはできません。


<h3>Assert 式</h3>

$(GRAMMAR
$(GNAME AssertExpression):
    $(B assert $(LPAREN)) $(GLINK AssignExpression) $(B $(RPAREN))
    $(B assert $(LPAREN)) $(GLINK AssignExpression) $(B ,) $(GLINK AssignExpression) $(B $(RPAREN))
)

        $(P $(I AssignExpression) を評価します。
	null でないクラス参照に評価された場合は、そのクラスの不変条件が実行されます。
	それ以外の場合で、構造体への null でないポインタへと評価された場合は、その構造体の不変条件が実行されます。
	それ以外の場合で、結果が false だった場合、
        $(B AssertError) 例外が投げられます。 true ならば、
        例外は投げられません。
        $(I expression) で、その挙動にプログラムが依存するような副作用が発生すると、
        それはエラーです。
	コンパイラーはassert式を全く評価しないことも許されています。
        assert 式の型は $(D void) です。
	このassertは、Dの
        $(DDLINK dbc, Contract Programming, 契約プログラミング)
        サポートの重要な一部をなしています。
        )

        $(P $(D assert(0)) は特殊な場合です。この式は、
        その部分が到達不能コードであることを示します。
	到達してしまった場合、 $(B AssertError)が送出されるか、
	プログラムが実行停止します。
	（x86 プロセッサでは、実行停止には  $(B HLT)
 	命令が使われます）
	コンパイラは、最適化やコード生成の段階で、
	実行がassert(0)の部分には到達しないことを仮定してよいものとします。
        )

        $(P 第二引数の $(I AssignExpression) がもしあれば、
	暗黙に $(V1 $(D char[]))$(V2 $(D const(char)[])) へ変換できる型である必要があります。
	この値は
	第一引数の結果がfalseの時に評価され、
        結果の文字列が $(B AssertError) のメッセージに追記されます。
        )

----
void main() {
  assert(0, "an" ~ " error message");
}
----

        $(P これをコンパイルして実行すると、次のメッセージが表示されます:)

$(CONSOLE
Error: AssertError Failure test.d(3) an error message
)


<h3>Mixin 式</h3>

$(GRAMMAR
$(GNAME MixinExpression):
    $(B mixin $(LPAREN)) $(GLINK AssignExpression) $(B $(RPAREN))
)

        $(P この $(I AssignExpression)
		はコンパイル時定数へと評価される文字列である必要があります。その文字列の内容は正当な
        $(I AssignExpression)としてコンパイルできるものでなければならず、
		その場合、その通りにコンパイルされます。
        )

---
int foo(int x) {
  return mixin("x + 1") * 7;  // ((x + 1) * 7) と同じ
}
---

<h3>Import 式</h3>

$(GRAMMAR
$(GNAME ImportExpression):
    $(B import $(LPAREN)) $(GLINK AssignExpression) $(B $(RPAREN))
)

        $(P $(I AssignExpression)
	はコンパイル時定数へと評価される文字列である必要があります。
	文字列の内容はファイル名として解釈されます。
	その名前のファイルが読み込まれ、
	ファイルの内容が文字列リテラルとなります。
        )

        $(P 処理系は、ディレクトリトラバーサル攻撃を防止するために、
	importに指定できるファイル名を制限する可能性があります。
	典型的な制約としては、ファイル名の中にパス区切り文字を含めない、
	などがあります。
        )

---
void foo() {
  // ファイル foo.txt の内容を表示
  write$(V1 f)ln( import("foo.txt") );
}
---

<h3>Typeid 式</h3>

$(GRAMMAR
$(GNAME TypeidExpression):
    $(B typeid $(LPAREN)) $(GLINK2 declaration, Type) $(B $(RPAREN))
$(V2      $(B typeid $(LPAREN)) $(GLINK Expression) $(B $(RPAREN)))
)

$(V1
        $(P $(I Type)
		に対応する
        $(DPLLINK phobos/object.html, $(B TypeInfo))
        のインスタンスを返します。
        )
)
$(V2
        $(P typeid に型 $(I Type)
		を指定した場合は、
		その型に対応した $(DPLLINK phobos/object.html, $(B TypeInfo))
        クラスのインスタンスを返します。
        )

        $(P $(I Expression) を指定した場合は、
		その式の型に対応した
        $(DPLLINK phobos/object.html, $(B TypeInfo))
        クラスのインスタンスを返します。
		クラス型の式であった場合、
		オブジェクトの動的な型に対応した $(B TypeInfo) が返ります。
        $(I Expression) は常に実行されます。
        )

---
class A { }
class B : A { }

void main() {
  writeln(typeid(int));  // int
  uint i;
  writeln(typeid(i++));  // uint
  writeln(i);            // 1
  A a = new B();
  writeln(typeid(a));    // B
  writeln(typeid(typeof(a)));  // A
}
---
)

<h3>Is 式</h3>

$(GRAMMAR
$(GNAME IsExpression):
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(B :) $(GLINK TypeSpecialization) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(B ==) $(GLINK TypeSpecialization) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(B :) $(GLINK TypeSpecialization) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(B ==) $(GLINK TypeSpecialization) $(B $(RPAREN))
    $(V2 $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(B :) $(GLINK TypeSpecialization) $(B ,) $(GLINK2 template, TemplateParameterList) $(B $(RPAREN))
    $(B is $(LPAREN)) $(GLINK2 declaration, Type) $(IDENTIFIER) $(B ==) $(GLINK TypeSpecialization) $(B ,) $(GLINK2 template, TemplateParameterList) $(B $(RPAREN))
)

$(GNAME TypeSpecialization):
    $(GLINK2 declaration, Type)
$(V1    $(B typedef)
)    $(B struct)
    $(B union)
    $(B class)
    $(B interface)
    $(B enum)
    $(B function)
    $(B delegate)
    $(B super)
$(V2      $(B const)
    $(B immutable)
    $(B inout)
    $(B shared)
    $(B return)
))

        $(I IsExpression) はコンパイル時に評価され、
	型の正当性を検査したり、型の同値性を比較したり、
	ある型から別の型へ暗黙変換できるかどうか確かめたり、
	型の部分型を推論したりするために使用します。
        $(I IsExpression) の結果はint型で、条件が不成立の場合0、
	成立した場合1になります。
        <p>

        $(I Type) はテストする型です。文法的には正しくなければなりませんが、
	意味的に正しい必要は必ずしもありません。
	意味的に不正な型だった場合、条件が不成立となります。
        <p>

        $(IDENTIFIER) は、条件が成立した場合、結果の型への
	alias となります。$(IDENTIFIER) 形式は、
        が $(I IsExpression)
        $(GLINK2 version, StaticIfCondition) の中に現れた時のみ使用できます。
        <p>

        $(I TypeSpecialization) は $(I Type)
	と比較して検査するために指定する対象の型式です。
        <p>

        $(I IsExpression) には以下のような種類があります：

        $(OL

        $(LI $(B is $(LPAREN)) $(I Type) $(B $(RPAREN))$(BR)
        $(I Type) が意味的に正当な型の時に、条件が成立します。
	（どの場合も文法的には正しい型を指定する必要があります）

-------------
alias int func(int);    // func は関数型への alias
void foo() {
  if ($(B is)(func[]) ) // 関数の配列は作れないので、
                        // 条件は満たされない
    write$(V1 f)ln("satisfied");
  else
    write$(V1 f)ln("not satisfied");

  if ($(B is)([][]))  // エラー。[][] は文法的に正しい型でない
    ...
}
-------------
        )

        $(LI $(B is $(LPAREN)) $(I Type) $(B :) $(I TypeSpecialization) $(B $(RPAREN))<br>
        $(I Type) が意味的に正しく、
        $(I TypeSpecialization)と同じかまたは暗黙に変換できる場合、
		条件成立となります。
		 $(I TypeSpecialization) の部分には型名のみ使用できます。

-------------
alias short bar;
void foo(bar x) {
  if ( $(B is)(bar : int) )   // shortはintに暗黙変換されるので
                              // 条件は満たされる
    write$(V1 f)ln("satisfied");
  else
    write$(V1 f)ln("not satisfied");
}
-------------
        )

        $(LI $(B is $(LPAREN)) $(I Type) $(B ==) $(I TypeSpecialization) $(B $(RPAREN))<br>
        $(I Type) が意味的に正当な型で、
        $(I TypeSpecialization)　と同じな時に条件成立です。
        <p>

        If $(I TypeSpecialization) が
$(V1            $(B typedef)
)               $(B struct)
                $(B union)
                $(B class)
                $(B interface)
                $(B enum)
                $(B function)
                $(B delegate)
$(V2            $(B const)
                $(B immutable)
                $(B shared)
)
        のいずれかの時は、 $(I Type) が指定の種類の型であれば条件成立となります。

-------------
alias short bar;
$(V1 typedef char foo;)
void test(bar x) {
  if ( $(B is)(bar == int) ) // shortはintと同じ型ではないので、
                        // 条件は満たされない
    write$(V1 f)ln("satisfied");
  else
    write$(V1 f)ln("not satisfied");
$(V1
  if ( $(B is)(foo == typedef) ) // foo が typedef なので満たされる
    write$(V1 f)ln("satisfied");
  else
    write$(V1 f)ln("not satisfied");
)}
-------------
        )

        $(LI $(B is $(LPAREN)) $(I Type) $(I Identifier) $(B $(RPAREN))<br>
        $(I Type) が意味的に正当な型であれば条件成立です。
	その場合、 $(I Identifier)
        が $(I Type) のaliasとして宣言されます。

-------------
alias short bar;
void foo(bar x) {
  static if ( $(B is)(bar T) )
    alias T S;
  else
    alias long S;

  write$(V1 f)ln(typeid(S));  // "short" と表示
  if ( $(B is)(bar T) )  // エラー、$(I Identifier) T の形式は
                      // $(GLINK2 version, StaticIfCondition) にしか使えない
    ...
}
-------------
        )

        $(LI $(B is $(LPAREN)) $(I Type) $(I Identifier) $(B :) $(I TypeSpecialization) $(B $(RPAREN))<br>

        $(P
        $(I Type) が
        $(I TypeSpecialization) と同じか、または $(I Type) がクラスで
        $(I TypeSpecialization) がその基底クラス/インターフェイスの場合、
        条件成立となります。
        $(I Identifier) は
        $(I TypeSpecialization) への alias として宣言されるか、または $(I TypeSpecialization) が
        $(I Identifier) に依存しているときは、推論された型へのaliasとなります。
        )

-------------
alias int bar;
alias long* abc;
void foo(bar x, abc a) {
  static if ( $(B is)(bar T : int) )
    alias T S;
  else
    alias long S;

  write$(V1 f)ln(typeid(S));  // "int" と表示

  static if ( $(B is)(abc U : U*) )
  {
    U u;
    write$(V1 f)ln(typeid(typeof(u)));  // "long" と表示
  }
}
-------------

        $(P $(I Identifier) の型を決定する方法は、
        $(GLINK2 template, TemplateTypeParameterSpecialization)
	の時にテンプレート引数型が決定されるのと同様の方法です。
        )
        )

        $(LI $(B is $(LPAREN)) $(I Type) $(I Identifier) $(B ==) $(I TypeSpecialization) $(B $(RPAREN))<br>


        $(P $(I Type) が意味的に正当な型で、
        $(I TypeSpecialization) と同じな時に条件成立です。
        $(I Identifier) は
        $(I TypeSpecialization) へのaliasとして宣言されるか、または、 $(I TypeSpecialization)
        が $(I Identifier) に依存しているときは、推論された型へのaliasとなります。
        )

        $(P If $(I TypeSpecialization) が
$(V1            $(B typedef)
)               $(B struct)
                $(B union)
                $(B class)
                $(B interface)
                $(B enum)
                $(B function)
                $(B delegate)
$(V2            $(B const)
                $(B immutable)
                $(B shared)
)
        のいずれかの時は、 $(I Type) が指定の種類の型であれば条件成立となります。
        さらに、$(I Identifier) は以下の型のaliasとなります：
        )

        $(TABLE1
        $(TR
        $(TH キーワード)
        $(TH $(I Identifier) の alias 先の型)
        )
$(V1    $(TR
        $(TD $(CODE typedef))
        $(TD $(I Type) の typedef 先)
        )
)
        $(TR
        $(TD $(CODE struct))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE union))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE class))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE interface))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE super))
        $(TD 基底クラスとインターフェイスからなる $(I TypeTuple))
        )
        $(TR
        $(TD $(CODE enum))
        $(TD enumの基底型)
        )
        $(TR
        $(TD $(CODE function))
        $(TD 関数の引数の $(I TypeTuple)。
	     C形式とD形式の可変個引数関数に対して使うと、
	     可変でない部分だけが含まれます。
	     型安全可変個引数では、... は無視されます。)
        )
        $(TR
        $(TD $(CODE delegate))
        $(TD delegate の関数型)
        )
        $(TR
        $(TD $(CODE return))
        $(TD 関数、delegate、関数ポインタの返値型)
        )
$(V2
        $(TR
        $(TD $(CODE const))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE immutable))
        $(TD $(I Type))
        )
        $(TR
        $(TD $(CODE shared))
        $(TD $(I Type))
        )
)
        )

-------------
alias short bar;
enum E : byte { Emember }
void foo(bar x) {
  static if ( $(B is)(bar T == int) ) // 満たされない。shortはintではない
    alias T S;
  alias T U;       // エラー、T は未定義

  static if ( $(B is)(E V == enum) )  // 満たされる。Eはenum
    V v;           // v はbyte型として宣言される
}
-------------

$(V1
        $(P たとえば、$(CODE X)
        が int への typedef かどうかを見るには:
        )
---
typedef int X;

static if (is(X base == typedef)) {
  static assert(is(base == int), "base of typedef X is not int");
}
else {
  static assert(0, "X is not a typedef");
}
---
)
        )

$(V2
        $(LI $(B is $(LPAREN)) $(I Type) $(I Identifier) $(B :) $(I TypeSpecialization) $(B ,) $(GLINK2 template, TemplateParameterList) $(B $(RPAREN))$(BR)
        $(B is $(LPAREN)) $(I Type) $(I Identifier) $(B ==) $(I TypeSpecialization) $(B ,) $(GLINK2 template, TemplateParameterList) $(B $(RPAREN))

        $(P もっと複雑な型をパターンマッチすることも可能です。
        $(GLINK2 template, TemplateParameterList) でシンボルを宣言して、
	型パターンの一部として使うことが出来ます。
	マッチ規則はテンプレート引数の場合と基本的に同様です。
        )

---
import std.stdio;

void main() {
  alias long[char[]] AA;

  static if (is(AA T : T[U], U : const char[]))
  {
    write$(V1 f)ln(typeid(T));  // long
    write$(V1 f)ln(typeid(U));  // const char[]
  }

  static if (is(AA A : A[B], B : int))
  {
    assert(0);  // Bはintではないのでマッチしない
  }

  static if (is(int[10] W : W[V], int V))
  {
    write$(V1 f)ln(typeid(W));  // int
    write$(V1 f)ln(V);          // 10
  }

  static if (is(int[10] X : X[Y], int Y : 5))
  {
    assert(0);  // Yは10なのでマッチしない
  }
}
---

        )
)
        )


<h2><a name="associativity">結合性と可換性</a></h2>

        $(P 実装によっては、
	一連の実行による結果が変化しない範囲で、
	演算子の算術的な結合性と可換性の規則にしたがって
	式を変形することがあります。
        )

        $(P 浮動小数点数は結合性/可換性を持たないため、
	この規則に基づいた式変形の対象からは除かれます。)
)

Macros:
        TITLE=式
        WIKI=Expression
	IDENTIFIER=$(GLINK2 lex, Identifier)
        CATEGORY_SPEC=$0
        FOO=


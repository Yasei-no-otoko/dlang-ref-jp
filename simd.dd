Ddoc

$(SPEC_S ベクトル演算拡張機能,

	$(P 近年の CPU は、"メディア命令" 
	などと呼ばれる特別なベクトル型とベクトル演算を提供することが多くなっています。
	ベクトル型は浮動小数点数や整数の固定長配列で、
	ベクトル演算はそれらの要素を同時に演算するもので、
	大幅な高速化に貢献します。)

	$(P 普通のD言語のコードで数値データをループ処理していたときに、これらの機能をコンパイラが活用することを、
	自動ベクトル化といいます。
	自動ベクトル化は、しかしながら、非常に限定された状況でのみ有効で、
	ネイティブのベクトル演算の豊富な（そしてしばしば奇妙な）
	機能を真に活用することはできていません。
	)

	$(P D には配列演算子式という記法があります。例えば:
	)

---
int[] a,b;
...
a[] += b[];
---

	$(P このコードはコンパイラによってベクトル化されますが、
	これも、自動ベクトル化と同様の理由によって効果は限定されています。
	)

	$(P ベクトル命令を通常の配列に対して適用することの難しさには、
	次のような理由があります:)

	$(OL
	$(LI ベクトル型には非常に厳密なアラインメントの要求が課せられていて、
	通常の配列ではこれを満たせません。)
	$(LI C 言語の ABI のベクトル演算は、
	特殊な名前マングリング規則とcall/return規約と記号デバッグサポートの下にあります。)
	$(LI ベクトル命令を完全に使いこなす唯一の方法は、インラインアセンブラを使うことです。
	しかし、コンパイラがインラインアセンブラのブロックを超えたレジスタ割り当て
	（やその他の最適化） ができないため、
	コードのパフォーマンスは落ちてしまいます。)
	$(LI 通常の配列処理をベクトル演算を同じデータに対して交互に混ぜると、
	知らないうちに非常に悪いパフォーマンスをもたらすことがあります。)
	)

	$(P 特殊なベクトル型を提供することで、これらの問題はなくなります。
	)

<h2>$(D core.simd)</h2>

	$(P D言語でベクトル型とベクトル演算を使うには、
	$(CORE_SIMD) を import します:)

---
import core.simd;
---

	$(P ここで定義される型と演算は、コンパイラの生成しているアーキテクチャの定義するものです。
	あるCPUファミリのベクトル型のサポートにばらつきがある場合は、
	実行時に利用可能性を検査する必要があるかもしれません。
	コンパイラは実行時チェックを生成しません; プログラマが気をつける必要があります。
	)

	$(P 型名は以下の命名規約にしたがっています:)

$(GRAMMAR
$(I typeNN)
)
	$(P $(I type) にはベクトルの要素の型が、$(I NN)
	にはその要素数が入ります。
	これらの型名は予約語ではありません。
	)

<h3>プロパティ</h3>

	$(P ベクトル型の持つプロパティは次の通りです:)

	$(TABLE2 ベクトル型のプロパティ,
	$(THEAD プロパティ, 説明)
	$(TROW .array, 静的配列としての表現を返す)
	)

	$(P 静的配列の持つプロパティも全て使うことができます)

<h3>変換</h3>

	$(P 同じサイズのベクトル型同士は暗黙に変換できます。
	ベクトル型は静的配列にキャストすることができます。)

	$(P 整数と浮動小数点数は対応するベクトル型に暗黙変換されます:
	)

---
int4 v = 7;
v = 3 * v;   // v の各要素に 3 を掛ける
---

<h3>ベクトルの要素への個別アクセス</h3>

	$(P 要素に直接アクセスすることはできませんが、o
	配列への変換を通すことで可能になります:)

----
int4 v;
(cast(int*)&v)[3] = 2;   // 4個のintベクトルの第3要素
cast(int[4])v[3] = 2;    // 4個のintベクトルの第3要素
v.array[3] = 2;          // 4個のintベクトルの第3要素
v.ptr[3] = 2;            // 4個のintベクトルの第3要素
----


<h3>条件コンパイル</h3>

	$(P ベクトル演算拡張が実装されていれば、
	$(DDSUBLINK version, PredefinedVersions, バージョン識別子)
	$(D D_SIMD) がセットされます)

	$(P 特定の型が存在するかどうかは、コンパイル時に
	 $(DDSUBLINK expression, IsExpression, $(I IsExpression)) でチェックできます:
	)

---
static if (is($(I typeNN)))
    ... ある ...
else
    ... ない ...
---

	$(P 特定の演算が利用可能かのチェックは、
	こうなります:
	)

---
float4 a,b;
static if (__traits(compiles, a+b))
    ... 使える ...
else
    ... 使えない ...
---

	$(P 特定のベクトル命令が使えるかの実行時のチェックには、
	$(LINK2 phobos/core_cpuid.html, core.cpuid) の関数を使います。
	)

	$(P 使えない場合の典型的な回避策は、配列ベクトル演算を代わりに使うことです:)

---
float4 a,b;
static if (__traits(compiles, a/b))
    c = a / b;
else
    c[] = a[] / b[];
---

<h2>X86 と X86_64 でのベクトル演算拡張の実装状況</h2>

	$(P 以下は、X86 と X86_64
	アーキテクチャでのベクトル型の対応の説明です。
	)

	$(P ベクトル演算は現在のところ OS X での 32bit ターゲットと、
	そのほかの 64 bit ターゲットでサポートされています。)

	$(P $(CORE_SIMD) には以下の型が定義されています:)

	$(TABLE2 ベクトル型,
	$(THEAD 型名, 説明, gccでの対応物)
	$(TROW void16, 16 バイトの型無しのデータ, $(I なし))
	$(TROW byte16, 16 個の $(D byte), $(D signed char __attribute((vector_size(16)))))
	$(TROW ubyte16, 16 個の $(D ubyte), $(D unsigned char __attribute((vector_size(16)))))
	$(TROW short8, 8 個の $(D short), $(D short __attribute((vector_size(16)))))
	$(TROW ushort8, 8 個の $(D ushort), $(D ushort __attribute((vector_size(16)))))
	$(TROW int4, 4 個の $(D int), $(D int __attribute((vector_size(16)))))
	$(TROW uint4, 4 個の $(D uint), $(D unsigned __attribute((vector_size(16)))))
	$(TROW long2, 2 個の $(D long), $(D long __attribute((vector_size(16)))))
	$(TROW ulong2, 2 個の $(D ulong), $(D unsigned long __attribute((vector_size(16)))))
	$(TROW float4, 4 個の $(D float), $(D float __attribute((vector_size(16)))))
	$(TROW double2, 2 個の $(D double), $(D double __attribute((vector_size(16)))))
	)

	$(P 注: 32 bit gcc では、$(D long) ではなく $(D long long) です。)

	$(TABLE2 対応済みベクトル演算,
	$(THEAD 演算子,void16,byte16,ubyte16,short8,ushort8,int4,uint4,long2,ulong2,float4,double2)
	$(TROW =,$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y))
	$(TROW + +=,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y))
	$(TROW - -=,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y))
	$(TROW * *=,$(N),$(N),$(N),$(Y),$(Y),$(N),$(N),$(N),$(N),$(Y),$(Y))
	$(TROW / /=,$(N),$(N),$(N),$(N),$(N),$(N),$(N),$(N),$(N),$(Y),$(Y))
	$(TROW &amp; &amp;=,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(N),$(N))
	$(TROW | |=,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(N),$(N))
	$(TROW ^ ^=,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(N),$(N))
	$(TROW $(I unary)~,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(N),$(N))
	$(TROW $(I unary)+,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y))
	$(TROW $(I unary)-,$(N),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y),$(Y))
	)

	$(P リストにない演算子には対応していません。)

<h3>ベクトル処理用組み込み演算</h3>

	$(P 対応している組み込み演算については $(CORE_SIMD) を参照してください)
)

Macros:
	TITLE=ベクトル演算拡張機能
	WIKI=Float
	Y=&times;
	N=&ndash;
	CORE_SIMD=$(LINK2 phobos/core_simd.html, $(D core.simd))
	CATEGORY_SPEC=$0

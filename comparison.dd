Ddoc

$(COMMUNITY $(B D) vs その他の言語,

	$(BLOCKQUOTE William Nerdspeare,
	To D, or not to D.
	)

	$(P この表は、よく他の言語と比べられる機能に関して、
	$(B D)
	のさまざまな特徴をリストアップしてみた結果です。
	どの言語も標準ライブラリによって得られる機能を多く持っていますが、
	ここでは言語そのものに組み込まれた特徴にのみ着目することにします。
	$(LINK2 builtin.html, その理由)
	)

	<table border=2 cellpadding=4 cellspacing=0 class="comp">
	<caption>D言語機能 比較表</caption>

	<thead>
	$(TR
	<th>機能</th>
	<th align="center"><a href="index.html" title="D Programming Language"  target="_top">$(B D)</a></th>
	)
	</thead>

	<tbody>

	$(TR
	$(TD <a href="#GarbageCollection">ガベージコレクション</a>)
	$(YES1 garbage.html)
	)

	$(TR
	<th colspan="6" align="left"> 関数</th>
	)

	$(TR
	$(TD 関数デリゲート)
	$(YES1 type.html#delegates)
	)

	$(TR
	$(TD 関数オーバーロード)
	$(YES1 function.html#function-overloading)
	)

	$(TR
	$(TD 出力パラメータ)
	$(YES1 function.html#parameters)
	)

	$(TR
	$(TD ネストした関数)
	$(YES1 function.html#nested)
	)

	$(TR
	$(TD 関数リテラル)
	$(YES1 expression.html#FunctionLiteral)
	)

	$(TR
	$(V1 $(TD 動的クロージャ))
	$(V2 $(TD クロージャ))
	$(YES1 function.html#closures)
	)

	$(TR
	$(TD 型安全な可変個引数)
	$(YES1 function.html#variadic)
	)

	$(TR
	$(TD 遅延関数引数評価)
	$(YES1 lazy-evaluation.html)
	)

	$(TR
	$(TD コンパイル時関数評価)
	$(YES1 function.html#interpretation)
	)

	$(TR
	<th colspan="6" align="left"> 配列</th>
	)

	$(TR
	$(TD Lightweightな配列)
	$(YES1 arrays.html)
	)

	$(TR
	$(TD <a href="#ResizeableArrays">可変サイズ配列</a>)
	$(YES1 arrays.html#resize)
	)

	$(TR
	$(TD <a href="#BuiltinStrings">組み込みの文字列</a>)
	$(YES1 arrays.html#strings)
	)

	$(TR
	$(TD 配列のスライシング)
	$(YES1 arrays.html#slicing)
	)

	$(TR
	$(TD 境界チェック)
	$(YES1 arrays.html#bounds)
	)

	$(TR
	$(TD 配列リテラル)
	$(YES1 expression.html#ArrayLiteral)
	)

	$(TR
	$(TD 連想配列)
	$(YES1 arrays.html#associative)
	)

	$(TR
	$(TD <a href="#StrongTypedefs">強い typedef</a>)
	$(YES1 declaration.html#typedef)
	)

	$(TR
	$(TD 文字列によるswitch)
	$(YES1 statement.html#SwitchStatement)
	)

	$(TR
	$(TD 型の別名定義)
	$(YES1 declaration.html#alias)
	)

	$(TR
	<th colspan="6" align="left"> オブジェクト指向プログラミング</th>
	)

	$(TR
	$(TD <a href="#ObjectOriented">オブジェクト指向</a>)
	$(YES)
	)

	$(TR
	$(TD 多重継承)
	$(NO)
	)

	$(TR
	$(TD <a href="#Interfaces">インターフェイス</a>)
	$(YES1 interface.html)
	)

	$(TR
	$(TD 演算子オーバーロード)
	$(YES1 operatoroverloading.html)
	)

	$(TR
	$(TD <a href="#Modules">モジュール</a>)
	$(YES1 module.html)
	)

	$(TR
	$(TD 動的なクラスのロード)
	$(NO)
	)

	$(TR
	$(TD ネストしたクラス</a>)
	$(YES1 class.html#nested)
	)

	$(TR
	$(TD <a href="#innerclasses">内部（アダプタ）クラス</a>)
	$(YES1 class.html#nested)
	)

	$(TR
	$(TD 共変の戻り値型)
	$(YES1 function.html)
	)

	$(TR
	$(TD プロパティ)
	$(YES1 property.html#classproperties)
	)

	$(TR
	<th colspan="6" align="left"> パフォーマンス</th>
	)

	$(TR
	$(TD <a href="#InlineAssembler">インラインアセンブラ</a>)
	$(YES1 iasm.html)
	)

	$(TR
	$(TD ハードウェアへの直接アクセス)
	$(YES)
	)

	$(TR
	$(TD Lightweightなオブジェクト)
	$(YES1 struct.html)
	)

	$(TR
	$(TD 明示的なメモリ割り当て制御)
	$(YES1 memory.html)
	)

	$(TR
	$(TD VM 非依存)
	$(YES)
	)

	$(TR
	$(TD  ネイティブコードの直接生成)
	$(YES)
	)

	$(TR
	<th colspan="6" align="left"> 総称プログラミング</th>
	)

	$(TR
	$(TD クラステンプレート)
	$(YES1 template.html)
	)

	$(TR
	$(TD 関数テンプレート)
	$(YES1 template.html)
	)

	$(TR
	$(TD 暗黙の関数テンプレートインスタンス化)
	$(YES1 template.html)
	)

	$(TR
	$(TD 部分・明示特殊化)
	$(YES1 template.html)
	)

	$(TR
	$(TD 値テンプレート引数)
	$(YES1 template.html)
	)

	$(TR
	$(TD テンプレートテンプレート引数)
	$(YES1 template.html)
	)

	$(TR
	$(TD 可変個テンプレート引数)
	$(YES1 template.html)
	)
$(V2
	$(TR
	$(TD テンプレート制約)
	$(YES1 concepts.html)
	)
)
	$(TR
	$(TD <a href="#mixins">ミックスイン</a>)
	$(YES1 template-mixin.html)
	)

	$(TR
	$(TD <a href="#staticif">static if</a>)
	$(YES1 version.html#staticif)
	)

	$(TR
	$(TD <a href="#isexpression">is式</a>)
	$(YES1 expression.html#IsExpression)
	)

	$(TR
	$(TD typeof)
	$(YES1 declaration.html#Typeof)
	)

	$(TR
	$(TD foreach)
	$(YES1 statement.html#ForeachStatement)
	)

	$(TR
	$(TD <a href="#ImplicitTypeInference">暗黙の型推論</a>)
	$(YES1 declaration.html#AutoDeclaration)
	)

	$(TR
	<th colspan="6" align="left"> 信頼性</th>
	)

	$(TR
	$(TD <a href="#Contracts">契約プログラミング</a>)
	$(YES1 dbc.html)
	)

	$(TR
	$(TD 単体テスト)
	$(YES1 unittest.html)
	)

	$(TR
	$(TD 静的オブジェクトの初期化順保証)
	$(YES1 module.html#staticorder)
	)

	$(TR
	$(TD 初期化済み保証)
	$(YES1 statement.html#DeclarationStatement)
	)

	$(TR
	$(TD RAII（自動デストラクタ）)
	$(YES1 memory.html#raii)
	)

	$(TR
	$(TD 例外処理)
	$(YES1 statement.html#TryStatement)
	)

	$(TR
	$(TD <a href="exception-safe.html">スコープガード</a>)
	$(YES1 statement.html#ScopeGuardStatement)
	)

	$(TR
	$(TD try-catch-finally ブロック)
	$(YES1 statement.html#TryStatement)
	)

	$(TR
	$(TD スレッド同期プリミティブ)
	$(YES1 statement.html#SynchronizedStatement)
	)

	$(TR
	<th colspan="6" align="left"> 互換性</th>
	)

	$(TR
	$(TD C言語風構文)
	$(YES)
	)

	$(TR
	$(TD 列挙型)
	$(YES1 enum.html)
	)

	$(TR
	$(TD <a href="#Ctypes">Cの全ての型のサポート</a>)
	$(YES1 type.html)
	)

	$(TR
	$(TD <a href="#LongDouble">80bit 浮動小数点数</a>)
	$(YES1 type.html)
	)

	$(TR
	$(TD 複素数, 虚数)
	$(YES1 type.html)
	)

	$(TR
	$(TD Cへの直接アクセス)
	$(YES1 attribute.html#linkage)
	)

	$(TR
	$(TD <a href="#debuggers">既存のデバッガを利用可能</a>)
	$(YES)
	)

	$(TR
	$(TD <a href="#StructMemberAlignmentControl">構造体のアラインメント</a>)
	$(YES1 attribute.html#align)
	)

	$(TR
	$(TD 標準的なオブジェクトファイルの生成)
	$(YES)
	)

	$(TR
	$(TD マクロテキストプリプロセッサ)
	$(NO1 pretod.html)
	)

	$(TR
	<th colspan="6" align="left"> その他</th>
	)

	$(TR
	$(TD 条件コンパイル)
	$(YES1 version.html)
	)

	$(TR
	$(TD Unicodeソースファイル)
	$(YES1 lex.html)
	)

	$(TR
	$(TD <a href="#DocComments">ドキュメント化コメント</a>)
	$(YES1 ddoc.html)
	)

	</tbody>

	</table>

$(SECTION2 注釈,

	<dl>

	<dt><a name="ObjectOriented">オブジェクト指向</a>
	<dd>これは、クラスやメンバ関数、継承、
		仮想関数によるディスパッチに対応していることを示しています。
	<p>

	<dt><a name="InlineAssembler">インラインアセンブラ</a>
	<dd> 多数のC/C++コンパイラがインラインアセンブラをサポートしてはいますが、
		これは言語の標準の一部となってはいません。
		各コンパイラ毎に構文はバラバラで、実装の質も統一されていません。
	<p>

	<dt><a name="Interfaces">インターフェイス</a>
	<dd> C++のインターフェイスへの対応は、IDL（インターフェイス定義言語）
		が開発されねばならなかった事実が示しているように、不十分です。
	<p>

	<dt><a name="Modules">モジュール</a>
	<dd> 多くの人がC++は正確にはモジュール機構を持っていない、と言うでしょう。
		しかし、C++の名前空間は、ヘッダファイルと組み合わせることで、
		モジュールの持つ機能の多くをカバーしています。
	<p>

	<dt><a name="GarbageCollection">ガベージコレクション</a>
	<dd> Hans-Boehm のガベージコレクタをC/C++プログラムでも用いることは可能ですが、
		これは言語の標準規格ではありません。
	<p>

	<dt><a name="ImplicitTypeInference">暗黙の型推論</a>
	<dd> これは、
		宣言の型をその初期化子から取ってくる機能を指しています。
	<p>

	<dt><a name="Contracts">契約プログラミング</a>
	<dd>Digital Mars C++ コンパイラは拡張として
	<a href="http://www.digitalmars.com/ctg/contract.html">契約プログラミング</a>
	をサポートしています。
	契約プログラミングを行うための <a href="cppdbc.html">C++ でのテクニック</a>
	とDとを比較してみてください。
	<p>

	<dt><a name="ResizeableArrays">可変サイズ配列</a>
	<dd>C++の標準ライブラリの一部として可変長配列が実装されていますが、
		言語そのものの一部ではありません。
		規格に適合したフリースタンディグ処理系 (C++98 17.4.1.3) でも、
		これらのライブラリを提供する必要は必ずしもありません。
	<p>

	<dt><a name="BuiltinStrings">組み込みの文字列</a>
	<dd>C++の標準ライブラリの一部として文字列(std::string)が実装されていますが、
		言語そのものの一部ではありません。
		規格に適合したフリースタンディグ処理系 (C++98 17.4.1.3) でも、
		これらのライブラリを提供する必要は必ずしもありません。
	$(REDO ここにC++のstringとDの組み込みの文字列との <a href="cppstrings.html">比較</a>
	があります。)
	<p>

	<dt><a name="StrongTypedefs">強いtypedef</a>
	<dd>強いtypedefは、型を構造体でラップすることで、C/C++でも擬似的に実現することはできます。
		しかしこの方法では非常に煩雑なプログラミングを強いられることになるため、
		C/C++は強いtypedefに対応していない、と言えるでしょう。
	<p>

	<dt><a name="debuggers">既存のデバッガを利用可能</a>
	<dd>これは、実行ファイル内のよくあるデータ形式を扱うことのできる、
		汎用デバッガの利用を意味しています。
		特定の言語を扱う場合にのみ役に立つ専用デバッガは必要となりません。
	<p>

	<dt><a name="StructMemberAlignmentControl">構造体のアラインメント</a>
	<dd>大多数の C/C++ コンパイラは構造体メンバのアラインメントを制御する
		pragma を備えていますが、標準規格ではなく、
		コンパイラ毎に互換性がありません。<br>
		C# 標準規格である ECMA-334 25.5.8 では、
		構造体メンバの整列については次のように述べられているのみです：
	$(I "The order in which members are packed
	into a struct is unspecified. For alignment purposes, there may be
	unnamed padding at the beginning of a struct, within a struct, and at
	the end of the struct. The contents of the bits used as padding are
	indeterminate.")
		それゆえ、Microsoft
		は特定のメンバの整列を拡張としてサポートしているかもしれませんが、
		それは公式なC#標準の一部ではないのです。
	<p>

	<dt><a name="Ctypes">Cの全ての型のサポート</a>
	<dd>C99 で、C++にない多くの型が追加されました。
	<p>

	<dt><a name="LongDouble">80bit 浮動小数点数</a>
	<dd>CとC++の規格ではlong double型について定められているにもかかわらず,
		実際には80bit(以上)の浮動小数点数を実装したコンパイラはあまりありません。
		（Digital Mars C/C++ を除いては。）
	<p>

	<dt><a name="mixins">ミックスイン</a>
	<dd>Mixinは、言語ごとに実に様々な定義をされています。
	<a href="template-mixin.html">D のミックスイン</a> は、
		任意の種類の宣言を取り出し、それらを現在のスコープへ挿入（ミックス）します。
		グローバル、クラス、構造体、ローカルの
		どのレベルでも宣言をMixinすることが可能です。
	<p>

	<dt><a name="cppmixins">C++ でのミックスイン</a>
	<dd>C++ の Mixin は、二つの異なった意味のテクニックを指しています。
		一つ目は、Dのインターフェイスクラスに似た物です。二つ目は、
		次の形式のテンプレートを作ることです：
$(CPPCODE
template &lt;class Base&gt; class Mixin : public Base
{
    ... mixin 本体 ...
}
)
		DのMixinとは異なります。
	<p>

	<dt><a name="staticif">static if</a>
	<dd>C や C++ のプリプロセッサの #if は、D の static if
	と同じ物と思えるかもしれません。しかし、これらの間には大きく決定的な違いがあります
	 - #if は、プログラム内の定数や型、その他のシンボルにアクセスできません。
	#if
	が扱えるのはプリプロセッサのマクロのみです。
	<a href="cpptod.html#metatemplates">この例</a> をご覧下さい。
	<p>

	<dt><a name="isexpression">is 式</a>
	<dd>$(I is式) によって、型の性質に基づいた条件コンパイルが可能になります。
	これは、テンプレート引数パターンマッチという方法を用いると
	C++ でも同じようなことが可能です。二つの異なるアプローチの比較については、
	<a href="cpptod.html#typetraits">この例</a>
	をご覧下さい。
	<p>

	<dt><a name="innerclasses">内部（アダプタ）クラス</a>
	<dd>$(I ネストしたクラス) というのは、
		定義が別のクラスのスコープの内側にあるもののことを指します。
	 	$(I 内部クラス) は、ネストしたクラスであって、
		外側のクラスのメンバを参照することができるもののことです。
		外側クラスの'this'ポインタを保持していると考えてもよいかもしれません。
	<p>

	<dt><a name="DocComments">ドキュメント化コメント</a>
	<dd>ドキュメント化コメントとは、
	特別な形式のコメントを使ってソースコードからドキュメントを生成する、
	標準化された方法のことを指しています。

	</dl>
)

$(SECTION2 間違い,

	$(P もしこの表について何か間違いがありましたら、お知らせ下さい。
	修正します。
	)
)

)

Macros:
	TITLE=比較
	WIKI=Comparison
	CATEGORY_FEATURES=$0
	NO=<td class="compNo">No</td>
	NO1=<td class="compNo"><a href="$1">No</a></td>
	YES=<td class="compYes">Yes</td>
	YES1=<td class="compYes"><a href="$1">Yes</a></td>

